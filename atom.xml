<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pola Bear&#39;s Blog</title>
  
  <subtitle>越美麗越不可觸碰</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-16T10:48:25.641Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>北極熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇总</title>
    <link href="http://yoursite.com/2017/10/16/%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2017/10/16/汇总/</id>
    <published>2017-10-16T08:09:08.000Z</published>
    <updated>2017-10-16T10:48:25.641Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些简单的名词缩写以及技术栈"><a href="#一些简单的名词缩写以及技术栈" class="headerlink" title="一些简单的名词缩写以及技术栈"></a><strong>一些简单的名词缩写以及技术栈</strong></h4><a id="more"></a><h6 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h6><p>（object relational mapping）對象關係映射</p><h6 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h6><p>（remote procedure call protocol） 遠程過程調用協議</p><h6 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h6><p>属于<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE" target="_blank" rel="external">远程访问</a>技术，简单地说就是利用<a href="https://baike.baidu.com/item/%E5%85%AC%E7%94%A8%E7%BD%91%E7%BB%9C" target="_blank" rel="external">公用网络</a>架设<a href="https://baike.baidu.com/item/%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C" target="_blank" rel="external">专用网络</a>。    跳板機</p><h6 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h6><p>（Virtual Private Server） 虚拟专用服务器</p><h6 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h6><p>（network file System） 網絡文件系統</p><h6 id="Owncloud"><a href="#Owncloud" class="headerlink" title="Owncloud"></a><a href="https://www.logcg.com/archives/2750.html" target="_blank" rel="external">Owncloud</a></h6><h6 id="Velocity技术"><a href="#Velocity技术" class="headerlink" title="Velocity技术"></a><a href="http://blog.csdn.net/fasttalk/article/details/398059/" target="_blank" rel="external">Velocity技术</a></h6><p>MVC框架显示层（速度）Java模版引擎技术　代替jsp</p><h6 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a><a href="http://koa.bootcss.com/#" target="_blank" rel="external">Koa</a></h6><p>基于node.js平台的下一代web开发框架（express团队）</p><h6 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000" target="_blank" rel="external">Node.js</a></h6><blockquote><p>运行在服务器端的js</p><p>grunt:将npm插件通过某些配置文件（package.json Gruntfile.js)的设置实现自动化执行 </p><p>npm：包管理程序，通过命令行与npm服务器连接并下载所需插件</p></blockquote><h6 id="Vue-React"><a href="#Vue-React" class="headerlink" title="Vue     React"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html" target="_blank" rel="external">Vue</a>     <a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">React</a></h6><p>前端框架 </p><h6 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><a href="http://www.docker.org.cn/book/docker/what-is-docker-16.html" target="_blank" rel="external">Docker</a></h6><p>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="http://www.runoob.com/redis/redis-intro.html" target="_blank" rel="external">Redis</a></h6><p>Redis是一个 <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80" target="_blank" rel="external">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。</p><h4 id="Java-Web项目框架"><a href="#Java-Web项目框架" class="headerlink" title="Java Web项目框架"></a>Java Web项目框架</h4><h6 id="1-S2SH-struts2-spring-hibernate"><a href="#1-S2SH-struts2-spring-hibernate" class="headerlink" title="1.S2SH(struts2+spring+hibernate)"></a>1.S2SH(struts2+spring+hibernate)</h6><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2177101238471680.htm" target="_blank" rel="external">基于Struts2+Spring3+Hibernate4开发java Web企业应用开源框架s2jh源码分享**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2168677709335552.htm" target="_blank" rel="external">spring+hibernate+struts2开发OA企业办公管理系统源码分享**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1550463494638592.htm" target="_blank" rel="external">Struts2+Hibernate3+Spring三大框架技术实现MySQL数据分页**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1550463430888448.htm" target="_blank" rel="external">Spring+struts2+hibernate+easyui基础权限管理框架**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2030578238245888.htm" target="_blank" rel="external">Spring+Struts2+Hibernate三大框架开发企业人力资源管理系统源代码下载**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1840816984820736.htm" target="_blank" rel="external">Spring mvc+struts2+Hibernate整合实例代码(注解详解)**</a></p><h6 id="2-S2SM-struts2-spring-mybatis"><a href="#2-S2SM-struts2-spring-mybatis" class="headerlink" title="2.S2SM(struts2+spring+mybatis)"></a>2.S2SM(struts2+spring+mybatis)</h6><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2141064953596928.htm" target="_blank" rel="external">Spring+Struts2+mybatis手动配置三大框架整合源代码下载**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1550463447796736.htm" target="_blank" rel="external">Struts2+mybatis开发音乐分享系统**</a></p><h6 id="3-SSH-spring-mvc-spring-hibernate或struts-spring-hibernate"><a href="#3-SSH-spring-mvc-spring-hibernate或struts-spring-hibernate" class="headerlink" title="3.SSH(spring mvc+spring+hibernate或struts+spring+hibernate)"></a>3.SSH(spring mvc+spring+hibernate或struts+spring+hibernate)</h6><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2287970382777344.htm" target="_blank" rel="external">Spring MVC+Spring+Hibrenarte实现的简单的CRUD项目实例**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2170238887660544.htm" target="_blank" rel="external">springMVC注解与hibernate完美结合完成基本的增删改查demo源码下载**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2139376672148480.htm" target="_blank" rel="external">springmvc+hibernate+spring+easyui开发bsalse进销存后台管理系统源代码下载**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2051547504970752.htm" target="_blank" rel="external">spring 3.0+spring MVC+Hibernate框架搭建教程(附：springMVC文件上传功能)**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2014401579273216.htm" target="_blank" rel="external">spring+struts2+Hibernate三大框架开发某制药厂管理系统源代码下载**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1840816984820736.htm" target="_blank" rel="external">Spring mvc+struts2+Hibernate整合实例代码(注解详解)**</a></p><h6 id="4-SSM-spring-mvc-spring-mybatis"><a href="#4-SSM-spring-mvc-spring-mybatis" class="headerlink" title="4.SSM(spring mvc+spring+mybatis)"></a>4.SSM(spring mvc+spring+mybatis)</h6><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1774043357989888.htm" target="_blank" rel="external">SpringMVC+Mybatis整合实现简单权限控制系统代码**</a></p><h6 id="5-JSJ-javabean-servlet-jsp"><a href="#5-JSJ-javabean-servlet-jsp" class="headerlink" title="5.JSJ(javabean+servlet+jsp)"></a>5.JSJ(javabean+servlet+jsp)</h6><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2251648892881920.htm" target="_blank" rel="external">jsp+servlet+javabean编写的一个java开源免费简易电子商城系统源码，适合初学者**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2016365453298688.htm" target="_blank" rel="external">JSP Servlet开发博客天空源代码下载**</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2005009709976576.htm" target="_blank" rel="external">JSP+servlet开发在线投票统计管理系统源代码下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一些简单的名词缩写以及技术栈&quot;&gt;&lt;a href=&quot;#一些简单的名词缩写以及技术栈&quot; class=&quot;headerlink&quot; title=&quot;一些简单的名词缩写以及技术栈&quot;&gt;&lt;/a&gt;&lt;strong&gt;一些简单的名词缩写以及技术栈&lt;/strong&gt;&lt;/h4&gt;
    
    </summary>
    
      <category term="技術" scheme="http://yoursite.com/categories/%E6%8A%80%E8%A1%93/"/>
    
    
      <category term="隨筆" scheme="http://yoursite.com/tags/%E9%9A%A8%E7%AD%86/"/>
    
  </entry>
  
  <entry>
    <title>springmvc常用注解标签详解</title>
    <link href="http://yoursite.com/2017/10/16/springmvc%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/10/16/springmvc常用注解标签详解/</id>
    <published>2017-10-16T02:39:23.000Z</published>
    <updated>2017-10-16T03:01:29.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springmvc常用注解标签详解"><a href="#springmvc常用注解标签详解" class="headerlink" title="springmvc常用注解标签详解"></a>springmvc常用注解标签详解</h1><h2 id="1、-Controller"><a href="#1、-Controller" class="headerlink" title="1、@Controller"></a>1、@Controller</h2><a id="more"></a><p>在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><p>　　（1）在SpringMVC 的配置文件中定义MyController 的bean 对象。</p><p>　　（2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--方式一--&gt;</div><div class="line">&lt;bean class=&quot;com.host.app.web.controller.MyController&quot;/&gt;</div><div class="line">&lt;!--方式二--&gt;</div><div class="line">&lt; context:component-scan base-package = &quot;com.host.app.web&quot; /&gt;//路径写到controller的上一层(扫描包详解见下面浅析)</div></pre></td></tr></table></figure><h2 id="2、-RequestMapping"><a href="#2、-RequestMapping" class="headerlink" title="2、@RequestMapping"></a>2、@RequestMapping</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p><p><strong>1、 value， method；</strong></p><p>value：     指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method：  指定请求的method类型， GET、POST、PUT、DELETE等；</p><p><strong>2、consumes，produces</strong></p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p>produces:    指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>3、params，headers</strong></p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h2 id="3、-Resource和-Autowired"><a href="#3、-Resource和-Autowired" class="headerlink" title="3、@Resource和@Autowired"></a>3、@Resource和@Autowired</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>1、共同点</strong></p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>2、不同点</strong></p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TestServiceImpl &#123;</div><div class="line">    // 下面两种@Autowired只要使用一种即可</div><div class="line">    @Autowired</div><div class="line">    private UserDao userDao; // 用于字段上</div><div class="line">    </div><div class="line">    @Autowired</div><div class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上</div><div class="line">        this.userDao = userDao;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestServiceImpl &#123;</div><div class="line">    @Autowired</div><div class="line">    @Qualifier(&quot;userDao&quot;)</div><div class="line">    private UserDao userDao; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TestServiceImpl &#123;</div><div class="line">    // 下面两种@Resource只要使用一种即可</div><div class="line">    @Resource(name=&quot;userDao&quot;)</div><div class="line">    private UserDao userDao; // 用于字段上</div><div class="line">    </div><div class="line">    @Resource(name=&quot;userDao&quot;)</div><div class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上</div><div class="line">        this.userDao = userDao;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p><h2 id="4、-ModelAttribute和-SessionAttributes"><a href="#4、-ModelAttribute和-SessionAttributes" class="headerlink" title="4、@ModelAttribute和 @SessionAttributes"></a>4、@ModelAttribute和 @SessionAttributes</h2><p>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p><p> @SessionAttributes即将值放到session作用域中，写在class上面。</p><p>具体示例参见下面：使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</p><h2 id="5、-PathVariable"><a href="#5、-PathVariable" class="headerlink" title="5、@PathVariable"></a>5、@PathVariable</h2><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Controller  </div><div class="line">public class TestController &#123;  </div><div class="line">     @RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)  </div><div class="line">     public String getLogin(@PathVariable(&quot;userId&quot;) String userId,  </div><div class="line">         @PathVariable(&quot;roleId&quot;) String roleId)&#123;  </div><div class="line">         System.out.println(&quot;User Id : &quot; + userId);  </div><div class="line">         System.out.println(&quot;Role Id : &quot; + roleId);  </div><div class="line">         return &quot;hello&quot;;  </div><div class="line">     &#125;  </div><div class="line">     @RequestMapping(value=&quot;/product/&#123;productId&#125;&quot;,method = RequestMethod.GET)  </div><div class="line">     public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123;  </div><div class="line">           System.out.println(&quot;Product Id : &quot; + productId);  </div><div class="line">           return &quot;hello&quot;;  </div><div class="line">     &#125;  </div><div class="line">     @RequestMapping(value=&quot;/javabeat/&#123;regexp1:[a-z-]+&#125;&quot;,  </div><div class="line">           method = RequestMethod.GET)  </div><div class="line">     public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123;  </div><div class="line">           System.out.println(&quot;URI Part 1 : &quot; + regexp1);  </div><div class="line">           return &quot;hello&quot;;  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><h2 id="6、-requestParam"><a href="#6、-requestParam" class="headerlink" title="6、@requestParam"></a>6、@requestParam</h2><p>@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。</p><h2 id="7、-ResponseBody"><a href="#7、-ResponseBody" class="headerlink" title="7、@ResponseBody"></a>7、@ResponseBody</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h2 id="8、-Component"><a href="#8、-Component" class="headerlink" title="8、@Component"></a>8、<strong>@Component</strong></h2><p>相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。</p><h2 id="9、-Repository"><a href="#9、-Repository" class="headerlink" title="9、@Repository"></a>9、@Repository</h2><p>用于注解dao层，在daoImpl类上面注解。</p><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><h4 id="1、使用-RequestMapping-来映射-Request-请求与处理器"><a href="#1、使用-RequestMapping-来映射-Request-请求与处理器" class="headerlink" title="1、使用 @RequestMapping 来映射 Request 请求与处理器"></a>1、使用 @RequestMapping 来映射 Request 请求与处理器</h4><p>方式一、通过常见的类路径和方法路径结合访问controller方法</p><p>方式二、使用uri模板</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping ( &quot;/test/&#123;variable1&#125;&quot; )</div><div class="line">public class MyController &#123;</div><div class="line"></div><div class="line">    @RequestMapping ( &quot;/showView/&#123;variable2&#125;&quot; )</div><div class="line">    public ModelAndView showView( @PathVariable String variable1, @PathVariable ( &quot;variable2&quot; ) int variable2) &#123;</div><div class="line">       ModelAndView modelAndView = new ModelAndView();</div><div class="line">       modelAndView.setViewName( &quot;viewName&quot; );</div><div class="line">       modelAndView.addObject( &quot; 需要放到 model 中的属性名称 &quot; , &quot; 对应的属性值，它是一个对象 &quot; );</div><div class="line">       return modelAndView;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>URI 模板就是在URI 中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI 模板<a href="http://localhost/app/{variable1}/index.html" target="_blank" rel="external">http://localhost/app/{variable1}/index.html</a> ，这个模板里面包含一个变量variable1 ，那么当我们请求<a href="http://localhost/app/hello/index.html" target="_blank" rel="external">http://localhost/app/hello/index.html</a> 的时候，该URL 就跟模板相匹配，只是把模板中的variable1 用hello 来取代。这个变量在SpringMVC 中是使用@PathVariable 来标记的。在SpringMVC 中，我们可以使用@PathVariable 来标记一个Controller 的处理方法参数，表示该参数的值将使用URI 模板中对应的变量的值来赋值。</p><p>代码中我们定义了两个URI 变量，一个是控制器类上的variable1 ，一个是showView 方法上的variable2 ，然后在showView 方法的参数里面使用<strong>@PathVariable</strong> 标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do 来请求的时候就可以访问到MyController 的showView 方法，这个时候variable1 就被赋予值hello ，variable2 就被赋予值2 ，然后我们在showView 方法参数里面标注了参数variable1 和variable2 是来自访问路径的path 变量，这样方法参数variable1 和variable2 就被分别赋予hello 和2 。方法参数variable1 是定义为String 类型，variable2 是定义为int 类型，像这种简单类型在进行赋值的时候Spring 是会帮我们自动转换的。</p><p>   在上面的代码中我们可以看到在标记variable1 为path 变量的时候我们使用的是@PathVariable ，而在标记variable2 的时候使用的是@PathVariable(“variable2”) 。这两者有什么区别呢？第一种情况就默认去URI 模板中找跟参数名相同的变量，但是这种情况只有在使用debug 模式进行编译的时候才可以，而第二种情况是明确规定使用的就是URI 模板中的variable2 变量。当不是使用debug 模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI 模板中的哪个变量。</p><p> 除了在请求路径中使用URI 模板，定义变量之外，<strong>@RequestMapping 中还支持通配符“* ”</strong>。如下面的代码我就可以使用/myTest/whatever/wildcard.do 访问到Controller 的testWildcard 方法。如：</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping ( &quot;/myTest&quot; )</div><div class="line">public class MyController &#123;</div><div class="line">    @RequestMapping ( &quot;*/wildcard&quot; )</div><div class="line">    public String testWildcard() &#123;</div><div class="line">       System. out .println( &quot;wildcard------------&quot; );</div><div class="line">       return &quot;wildcard&quot; ;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>当@RequestParam中没有指定参数名称时，Spring 在代码是debug 编译的情况下会默认取更方法参数同名的参数，如果不是debug 编译的就会报错。</p><h4 id="2、使用-RequestMapping-的一些高级用法"><a href="#2、使用-RequestMapping-的一些高级用法" class="headerlink" title="2、使用 @RequestMapping 的一些高级用法"></a>2、使用 @RequestMapping 的一些高级用法</h4><p>（1）params属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping (value= &quot;testParams&quot; , params=&#123; &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; &#125;)</div><div class="line">    public String testParams() &#123;</div><div class="line">       System. out .println( &quot;test Params...........&quot; );</div><div class="line">       return &quot;testParams&quot; ;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。</p><p>（2）method属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping (value= &quot;testMethod&quot; , method=&#123;RequestMethod. GET , RequestMethod. DELETE &#125;)</div><div class="line">    public String testMethod() &#123;</div><div class="line">       return &quot;method&quot; ;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。</p><p>（3）headers属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping (value= &quot;testHeaders&quot; , headers=&#123; &quot;host=localhost&quot; , &quot;Accept&quot; &#125;)</div><div class="line">    public String testHeaders() &#123;</div><div class="line">       return &quot;headers&quot; ;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。</p><h3 id="3、-RequestMapping-标记的处理器方法支持的方法参数和返回类型"><a href="#3、-RequestMapping-标记的处理器方法支持的方法参数和返回类型" class="headerlink" title="3、 @RequestMapping 标记的处理器方法支持的方法参数和返回类型"></a>3、 @RequestMapping 标记的处理器方法支持的方法参数和返回类型</h3><h4 id="1-支持的方法参数类型"><a href="#1-支持的方法参数类型" class="headerlink" title="1. 支持的方法参数类型"></a>1. 支持的方法参数类型</h4><p>​         <strong>（1 ）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 </strong>这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。</p><p>   <strong>（2 ）Spring 自己的WebRequest 对象。 </strong>使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</p><p>   <strong>（3 ）InputStream 、OutputStream 、Reader 和Writer 。 </strong>InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</p><p>   <strong>（4 ）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。</strong></p><p><strong>   **</strong>（5 ）使用@ModelAttribute 标记的参数。**</p><p><strong>   **</strong>（6 ）java.util.Map 、Spring 封装的Model 和ModelMap 。 **这些都可以用来封装模型数据，用来给视图做展示。</p><p>   <strong>（7 ）实体类。 </strong>可以用来接收上传的参数。</p><p>   <strong>（8 ）Spring 封装的MultipartFile 。 </strong>用来接收上传文件的。</p><p>   <strong>（9 ）Spring 封装的Errors 和BindingResult 对象。 </strong>这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</p><h4 id="2-支持的返回类型"><a href="#2-支持的返回类型" class="headerlink" title="2. 支持的返回类型"></a>2. 支持的返回类型</h4><p>   （1 ）一个包含模型和视图的ModelAndView 对象。</p><p>   （2 ）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</p><p>   （3 ）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</p><p>   （4 ）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</p><p>   （5 ）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</p><p>   （6 ）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</p><p>   （7 ）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</p><h3 id="4、使用-ModelAttribute-和-SessionAttributes-传递和保存数据"><a href="#4、使用-ModelAttribute-和-SessionAttributes-传递和保存数据" class="headerlink" title="4、使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据"></a>4、使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</h3><p>SpringMVC 支持使用 @<strong>ModelAttribute</strong> 和 @<strong>SessionAttributes</strong> 在不同的模型（model）和控制器之间共享数据。 <strong>@ModelAttribute </strong>主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。</p><p>当 @<strong>ModelAttribute</strong> 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @<strong>ModelAttribute</strong>(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping ( &quot;/myTest&quot; )</div><div class="line">public class MyController &#123;</div><div class="line"></div><div class="line">    @ModelAttribute ( &quot;hello&quot; )</div><div class="line">    public String getModel() &#123;</div><div class="line">       System. out .println( &quot;-------------Hello---------&quot; );</div><div class="line">       return &quot;world&quot; ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ModelAttribute ( &quot;intValue&quot; )</div><div class="line">    public int getInteger() &#123;</div><div class="line">       System. out .println( &quot;-------------intValue---------------&quot; );</div><div class="line">       return 10;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @RequestMapping ( &quot;sayHello&quot; )</div><div class="line">    public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpSession session) throws IOException &#123;</div><div class="line">       writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);</div><div class="line">       writer.write( &quot;\r&quot; );</div><div class="line">       Enumeration enume = session.getAttributeNames();</div><div class="line">       while (enume.hasMoreElements())</div><div class="line">           writer.write(enume.nextElement() + &quot;\r&quot; );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ModelAttribute ( &quot;user2&quot; )</div><div class="line">    public User getUser()&#123;</div><div class="line">       System. out .println( &quot;---------getUser-------------&quot; );</div><div class="line">       return new User(3, &quot;user2&quot; );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。执行结果如下所示：</p><ul><li>Hello world,Hello user210*</li></ul><p>​       由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码：</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping ( &quot;/myTest&quot; )</div><div class="line">@SessionAttributes (value=&#123; &quot;intValue&quot; , &quot;stringValue&quot; &#125;, types=&#123;User. class &#125;)</div><div class="line">public class MyController &#123;</div><div class="line"></div><div class="line">    @ModelAttribute ( &quot;hello&quot; )</div><div class="line">    public String getModel() &#123;</div><div class="line">       System. out .println( &quot;-------------Hello---------&quot; );</div><div class="line">       return &quot;world&quot; ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ModelAttribute ( &quot;intValue&quot; )</div><div class="line">    public int getInteger() &#123;</div><div class="line">       System. out .println( &quot;-------------intValue---------------&quot; );</div><div class="line">       return 10;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    @RequestMapping ( &quot;sayHello&quot; )</div><div class="line">    public void sayHello(Map&lt;String, Object&gt; map, @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpServletRequest request) throws IOException &#123;</div><div class="line">       map.put( &quot;stringValue&quot; , &quot;String&quot; );</div><div class="line">       writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);</div><div class="line">       writer.write( &quot;\r&quot; );</div><div class="line">       HttpSession session = request.getSession();</div><div class="line">       Enumeration enume = session.getAttributeNames();</div><div class="line">       while (enume.hasMoreElements())</div><div class="line">           writer.write(enume.nextElement() + &quot;\r&quot; );</div><div class="line">       System. out .println(session);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ModelAttribute ( &quot;user2&quot; )</div><div class="line">    public User getUser() &#123;</div><div class="line">       System. out .println( &quot;---------getUser-------------&quot; );</div><div class="line">       return new User(3, &quot;user2&quot; );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候，结果如下：</p><ul><li>Hello world,Hello user210*</li></ul><p>仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。所以当请求第二次的时候就会出现如下结果：</p><ul><li>Hello world,Hello user210*</li></ul><p><em>user2</em></p><p><em>intValue</em></p><p><em>stringValue</em></p><p>当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p><h3 id="5、-PathVariable和-RequestParam的区别"><a href="#5、-PathVariable和-RequestParam的区别" class="headerlink" title="5、@PathVariable和@RequestParam的区别"></a>5、@PathVariable和@RequestParam的区别</h3><p>请求路径上有个id的变量值，可以通过@PathVariable来获取  @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)<br>@RequestParam用来获得静态的URL请求入参     spring注解时action里用到。</p><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型）</p><p>A、处理<strong>requet uri </strong>部分（这里指uri template中variable，不含queryString部分）的注解：   @PathVariable;</p><p>B、处理<strong>request header</strong>部分的注解：   @RequestHeader, @CookieValue;</p><p>C、处理<strong>request body</strong>部分的注解：@RequestParam,  @RequestBody;</p><p>D、处理<strong>attribute</strong>类型是注解： @SessionAttributes, @ModelAttribute;</p><h4 id="（1）、-PathVariable"><a href="#（1）、-PathVariable" class="headerlink" title="（1）、@PathVariable"></a>（1）、@PathVariable</h4><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><p>示例代码：</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Controller  </div><div class="line">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </div><div class="line">public class RelativePathUriTemplateController &#123;  </div><div class="line">  </div><div class="line">  @RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)  </div><div class="line">  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </div><div class="line">    // implementation omitted   </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h4 id="（2）、-RequestHeader、-CookieValue"><a href="#（2）、-RequestHeader、-CookieValue" class="headerlink" title="（2）、 @RequestHeader、@CookieValue"></a>（2）、 @RequestHeader、@CookieValue</h4><p>@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。</p><p>示例代码：</p><p>这是一个Request 的header部分：</p><ol><li>Host                    localhost:8080  </li><li>Accept                  text/html,application/xhtml+xml,application/xml;q=0.9  </li><li>Accept-Language         fr,en-gb;q=0.7,en;q=0.3  </li><li>Accept-Encoding         gzip,deflate  </li><li>Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7  </li><li>Keep-Alive              300  </li></ol><ol><li>@RequestMapping(“/displayHeaderInfo.do”)  </li></ol><ol><li><strong>public</strong> <strong>void</strong> displayHeaderInfo(@RequestHeader(“Accept-Encoding”) String encoding,  </li><li>​                              @RequestHeader(“Keep-Alive”) <strong>long</strong> keepAlive)  {  </li><li>}  </li></ol><p>上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。</p><p>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。</p><p>例如有如下Cookie值：</p><p>　　JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)  </div><div class="line">public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  &#123;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>即把JSESSIONID的值绑定到参数cookie上。</p><h4 id="（3）、-RequestParam-RequestBody"><a href="#（3）、-RequestParam-RequestBody" class="headerlink" title="（3）、@RequestParam, @RequestBody"></a>（3）、@RequestParam, @RequestBody</h4><p>@RequestParam </p><p>A） 常用来处理简单类型的绑定，<strong>通过Request.getParameter() 获取的String可直接转换为简单类型的情况</strong>（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理<strong>get 方式中queryString的值</strong>，也可以处理<strong>post方式中 body data的值</strong>；</p><p>B）用来处理Content-Type: 为 <code>application/x-www-form-urlencoded</code>编码的内容，提交方式GET、POST；</p><p>C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</p><p>示例代码：</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Controller  </div><div class="line">@RequestMapping(&quot;/pets&quot;)  </div><div class="line">@SessionAttributes(&quot;pet&quot;)  </div><div class="line">public class EditPetForm &#123;  </div><div class="line">    @RequestMapping(method = RequestMethod.GET)  </div><div class="line"> public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) &#123;  </div><div class="line">       Pet pet = this.clinic.loadPet(petId);  </div><div class="line">   model.addAttribute(&quot;pet&quot;, pet);  </div><div class="line">   return &quot;petForm&quot;;  </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>@RequestBody</p><p>该注解常用来处理Content-Type: 不是<code>application/x-www-form-urlencoded</code>编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的<code>HttpMessageConverters</code>来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 <code>application/x-www-form-urlencoded</code>的内容，处理完的结果放在一个MultiValueMap<string, string="">里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</string,></p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)  </div><div class="line">public void handle(@RequestBody String body, Writer writer) throws IOException &#123;  </div><div class="line">  writer.write(body);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="（4）、-SessionAttributes-ModelAttribute"><a href="#（4）、-SessionAttributes-ModelAttribute" class="headerlink" title="（4）、@SessionAttributes, @ModelAttribute"></a>（4）、@SessionAttributes, @ModelAttribute</h4><p>@SessionAttributes:</p><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。</p><p>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Controller  </div><div class="line">@RequestMapping(&quot;/editPet.do&quot;)  </div><div class="line">@SessionAttributes(&quot;pet&quot;)  </div><div class="line">public class EditPetForm &#123;  </div><div class="line">    // ...   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@ModelAttribute</p><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；</p><p>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p><p>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：</p><p>A） @SessionAttributes 启用的attribute 对象上；</p><p>B） @ModelAttribute 用于方法上时指定的model对象；</p><p>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p><p>用到方法上@ModelAttribute的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@ModelAttribute  </div><div class="line">public Account addAccount(@RequestParam String number) &#123;  </div><div class="line">    return accountManager.findAccount(number);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）。</p><p>用在参数上的@ModelAttribute示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)  </div><div class="line">public String processSubmit(@ModelAttribute Pet pet) &#123;  </div><div class="line">     </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6、&lt; context:component-scan base-package = &quot;&quot; /&gt;浅析</div></pre></td></tr></table></figure><p>component-scan 默认扫描的注解类型是 @Component，不过，在 @Component 语义基础上细化后的 @Repository, @Service 和 @Controller 也同样可以获得 component-scan 的青睐</p><p>有了<context:component-scan>，另一个<context:annotation-config>标签根本可以移除掉，因为已经被包含进去了</context:annotation-config></context:component-scan></p><p>另外<context:annotation-config>还提供了两个子标签</context:annotation-config></p><ol><li><p><context:include-filter> //指定扫描的路径</context:include-filter></p></li><li><p><context:exclude-filter> //排除扫描的路径</context:exclude-filter></p></li></ol><p><context:component-scan>有一个use-default-filters属性，属性默认为true,表示会扫描指定包下的全部的标有@Component的类，并注册成bean.也就是@Component的子注解@Service,@Reposity等。</context:component-scan></p><p>这种扫描的粒度有点太大，如果你只想扫描指定包下面的Controller或其他内容则设置use-default-filters属性为false，表示不再按照scan指定的包扫描，而是按照<context:include-filter>指定的包扫描，示例：</context:include-filter></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;com.tan&quot; use-default-filters=&quot;false&quot;&gt;</div><div class="line">        &lt;context:include-filter type=&quot;regex&quot; expression=&quot;com.tan.*&quot;/&gt;//注意后面要写.*</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当没有设置use-default-filters属性或者属性为true时，表示基于base-packge包下指定扫描的具体路径</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;com.tan&quot; &gt;</div><div class="line">        &lt;context:include-filter type=&quot;regex&quot; expression=&quot;.controller.*&quot;/&gt;</div><div class="line">        &lt;context:include-filter type=&quot;regex&quot; expression=&quot;.service.*&quot;/&gt;</div><div class="line">        &lt;context:include-filter type=&quot;regex&quot; expression=&quot;.dao.*&quot;/&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">效果相当于：</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;com.tan&quot; &gt;</div><div class="line">        &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;.model.*&quot;/&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意：本人尝试时无论哪种情况&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;都不能同时存在</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;springmvc常用注解标签详解&quot;&gt;&lt;a href=&quot;#springmvc常用注解标签详解&quot; class=&quot;headerlink&quot; title=&quot;springmvc常用注解标签详解&quot;&gt;&lt;/a&gt;springmvc常用注解标签详解&lt;/h1&gt;&lt;h2 id=&quot;1、-Controller&quot;&gt;&lt;a href=&quot;#1、-Controller&quot; class=&quot;headerlink&quot; title=&quot;1、@Controller&quot;&gt;&lt;/a&gt;1、@Controller&lt;/h2&gt;
    
    </summary>
    
      <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Friday</title>
    <link href="http://yoursite.com/2017/10/13/Friday/"/>
    <id>http://yoursite.com/2017/10/13/Friday/</id>
    <published>2017-10-13T06:35:36.000Z</published>
    <updated>2017-10-16T03:02:13.973Z</updated>
    
    <content type="html"><![CDATA[<h5 id="嘻嘻"><a href="#嘻嘻" class="headerlink" title="嘻嘻"></a>嘻嘻</h5><a id="more"></a><p>有了博客之后就可以隔断时间记录一下心情或者心得 标签怎么分咧 </p><p>心得是学习后自己的总结 笔记是别人的总结 随笔就是日记吧 还有什么再补充就好了</p><p>但随笔要设密码诶 不然都被你们看到了 但好像github可以看源代码诶 那就有点傻了</p><h5 id="一眨眼就过了两个月了"><a href="#一眨眼就过了两个月了" class="headerlink" title="一眨眼就过了两个月了"></a>一眨眼就过了两个月了</h5><p>前端学了thymeleaf vue.js react js jquery ajax 但都只是单纯的会 才做了一个项目 感觉很多东西还不够熟练 接下去要往后端走了</p><blockquote><p>博客搭好了</p></blockquote><p>接下来的目标</p><ul><li style="list-style: none"><input type="checkbox"> springboot </li><li style="list-style: none"><input type="checkbox"> redis</li><li style="list-style: none"><input type="checkbox"> docker</li><li style="list-style: none"><input type="checkbox"> Nginx </li><li style="list-style: none"><input type="checkbox"> 搭一个用springboot+mybaits或者hibernate的项目</li><li style="list-style: none"><input type="checkbox"> 改一个restful风格的项目</li></ul><p>会不会有点多 感觉越进去越多东西学 还想学C语言 还要学matlab学数值计算 烦死我啦</p><h5 id="想想有什么是好玩的想自己搞的"><a href="#想想有什么是好玩的想自己搞的" class="headerlink" title="想想有什么是好玩的想自己搞的"></a>想想有什么是好玩的想自己搞的</h5><ul><li><p>之前自制的浏览器页面还需要美化一下</p></li><li><p>搭一个系统 可以记录一些用户名密码等 或者单纯记录</p><p>​</p></li></ul><h5 id="没啦-么么哒"><a href="#没啦-么么哒" class="headerlink" title="没啦 么么哒"></a>没啦 么么哒</h5>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;嘻嘻&quot;&gt;&lt;a href=&quot;#嘻嘻&quot; class=&quot;headerlink&quot; title=&quot;嘻嘻&quot;&gt;&lt;/a&gt;嘻嘻&lt;/h5&gt;
    
    </summary>
    
      <category term="日記" scheme="http://yoursite.com/categories/%E6%97%A5%E8%A8%98/"/>
    
    
      <category term="隨筆" scheme="http://yoursite.com/tags/%E9%9A%A8%E7%AD%86/"/>
    
  </entry>
  
  <entry>
    <title>Git上传</title>
    <link href="http://yoursite.com/2017/10/13/Git%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2017/10/13/Git上传/</id>
    <published>2017-10-13T06:09:57.000Z</published>
    <updated>2017-10-17T03:45:28.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>怎样上传代码</p></blockquote><h5 id="第一步：建立git仓库"><a href="#第一步：建立git仓库" class="headerlink" title="第一步：建立git仓库"></a><strong>第一步：建立git仓库</strong></h5><p>cd到你的本地项目根目录下，执行git命令</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure><p><strong>第二步：将项目的所有文件添加到仓库中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .</div></pre></td></tr></table></figure><p><strong>如果想添加某个特定的文件，只需把.换成特定的文件名即可</strong></p><p><strong>第三步：将add的文件commit到仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;注释语句&quot;</div></pre></td></tr></table></figure><hr><p><strong>第四步：去github上创建自己的Repository，创建页面如下图所示：</strong> </p><p><strong>点击下面的Create repository，就会进入到类似下面的一个页面，拿到创建的仓库的https地址，红框标示的就是</strong> </p><p><strong>第五步：重点来了，将本地的仓库关联到github上</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin https://github.com/hanhailong/CustomRatingBar</div></pre></td></tr></table></figure><p><strong>后面的https链接地址换成你自己的仓库url地址，也就是上面红框中标出来的地址</strong></p><p><strong>第六步：上传github之前，要先pull一下，执行如下命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull origin master</div></pre></td></tr></table></figure><p><strong>第七步，也就是最后一步，上传代码到github远程仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure><p><strong>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了</strong></p><blockquote><h4 id="如何把你对自己项目的改动，给发到之前fork的那个原项目"><a href="#如何把你对自己项目的改动，给发到之前fork的那个原项目" class="headerlink" title="如何把你对自己项目的改动，给发到之前fork的那个原项目"></a>如何把你对自己项目的改动，给发到之前fork的那个原项目</h4></blockquote><p><strong>pull request</strong></p><blockquote><p>自己fork的项目怎么做到和原项目同步</p></blockquote><p>你先git clone我的代码到本地，然后修修改改，然后你不是不能push到我的项目里么，你可以先在github页面上fork我的项目，有了你自己的项目地址（url）之后呢，</p><p>你在本地操作git remote add [sort name] [your url]，意思就是添加第二个远程仓库地址，这个仓库的“昵称”就是你刚指定的[sort name]，</p><p>你之后push文件呢 就通过指定这个［sort name］来push到这个你自己的仓库里</p><p>等你觉得想要把你改的发给原项目同步，就在你的项目上点Pull request按钮.说下另一种情况，</p><p>如果是原项目发生了改动，你要想同步到本地，就直接从git fetch origin 从原项目的地址同步代码，然后再merge就好了</p><p>当然，你可以通过新建分支的方式往自己的项目上push，这样同步的时候直接fetch就行了。</p><h4 id="今天使用git-添加远程github仓库的时候提示错误：fatal-remote-origin-already-exists"><a href="#今天使用git-添加远程github仓库的时候提示错误：fatal-remote-origin-already-exists" class="headerlink" title="今天使用git 添加远程github仓库的时候提示错误：fatal: remote origin already exists."></a>今天使用git 添加远程github仓库的时候提示错误：fatal: remote origin already exists.</h4><p>1、先删除远程 Git 仓库<br>$ git init<br>$ git add .<br>$ git commit -m “”<br>$ git remote rm origin<br>$ git remote add origin git@github.com:FBing/java-code-generator<br>$ git pull origin master —-allow-unrelated-histories<br>$ git pull origin master<br>$ git push -u origin master</p><h4 id="時間穿梭"><a href="#時間穿梭" class="headerlink" title="時間穿梭"></a>時間穿梭</h4><h5 id="刪除文件"><a href="#刪除文件" class="headerlink" title="刪除文件"></a>刪除文件</h5><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- test.txt</div></pre></td></tr></table></figure><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong></p><h4 id="遠程倉庫"><a href="#遠程倉庫" class="headerlink" title="遠程倉庫"></a>遠程倉庫</h4><h5 id="添加到遠程庫"><a href="#添加到遠程庫" class="headerlink" title="添加到遠程庫"></a>添加到遠程庫</h5><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。</p><hr><h5 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">创建版本库</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init  #初始化所在目录为Git仓库</div></pre></td></tr></table></figure><blockquote><p>初始化的目录可以不为空</p></blockquote><h5 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add &lt;file&gt; ...  #添加文件到暂存区（stage）</div><div class="line">        -f &lt;file&gt; ...  #强制添加到暂存区（可用于添加忽略文件）</div><div class="line">git commit -m &quot;提交说明&quot;  #从暂存区提交到版本库</div></pre></td></tr></table></figure><blockquote><p>git add 命令可多次执行，然后commit一次。</p></blockquote><h5 id="時光機穿梭"><a href="#時光機穿梭" class="headerlink" title="時光機穿梭"></a>時光機穿梭</h5><ul><li><h6 id="查看状态、差异"><a href="#查看状态、差异" class="headerlink" title="查看状态、差异"></a>查看状态、差异</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git status  #查看仓库当前状态</div><div class="line">git diff [file]  #比较工作区和暂存区的差异</div><div class="line">git diff --cached [file]  #比较暂存区和版本库的差异</div><div class="line">git diff HEAD -- [file]  #比较工作区和版本库的差异</div></pre></td></tr></table></figure><ul><li><h6 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">git log  #查看提交历史</div><div class="line">git log -1  #查看最后一次提交信息（-2 则是最后两次）</div><div class="line">git log --pretty=oneline  #单行格式显示提交历史</div><div class="line">        --graph  #显示分支合并图</div><div class="line">        --abbrev-commit  #简写的commit_id</div><div class="line">git reflog  #查看所有操作记录，包括删除的commit记录</div><div class="line">git reset --hard HEAD^  #回退到上一版本</div><div class="line"># HEAD 表当前版本， HEAD^ 表上一版本，HEAD^^ 表上两版本，HEAD~99 表上99版本。</div><div class="line">git reset --hard commit_id  #切换到指定版本</div></pre></td></tr></table></figure><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><blockquote><p>Git跟踪管理的是修改，而非文件</p></blockquote><ul><li><h6 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout -- &lt;file&gt;  #撤销工作区的修改</div><div class="line">git reset HEAD &lt;file&gt;  #撤销暂存区的修改</div></pre></td></tr></table></figure><blockquote><p>若已commit但没提交到远程库，可用版本回退进行撤销</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="external">版本回退</a>一节，不过前提是没有推送到远程库。</p></blockquote><ul><li><h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><ul><li>方法一：工作区删除文件，然后正常提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm &lt;file&gt; ...  #工作区删除</div><div class="line">git add &lt;file&gt; ...  #将修改提交至暂存区</div><div class="line">git commit -m &quot;说明&quot;  #提交到版本库</div></pre></td></tr></table></figure><ul><li>方法二：直接命令删除工作区和暂存区，然后提交版本库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm &lt;file&gt; ...  #删除工作区和暂存区文件</div><div class="line">git commit -m &quot;说明&quot;  #提交到版本库</div></pre></td></tr></table></figure></li></ul><blockquote><p>删除、增加文件也都属于修改</p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; $ git checkout -- test.txt</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong></p></blockquote><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><ul><li><h6 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  #生成的Key在家目录.ssh文件夹里面，pub后缀是公钥，另一个是私钥。</div></pre></td></tr></table></figure><ul><li><h6 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@server-name:path/repo-name.git  #添加远程仓库</div><div class="line">git remote  #查看远程库信息</div><div class="line">           -v  #显示详细信息</div><div class="line">git push -u origin &lt;branch&gt;  #推送并关联指定分支到远程库</div></pre></td></tr></table></figure><blockquote><p>除第一次关联，之后push不用加-u选项</p></blockquote><ul><li><h6 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone git@server-name:path/repo-name.git  #将远程仓库克隆到当前目录</div><div class="line">git pull  #拉取远程仓库内容</div></pre></td></tr></table></figure><h6 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">git branch &lt;branch&gt;  #创建分支</div><div class="line">git checkout &lt;branch&gt;  #切换到指定分支</div><div class="line">git checkout -b &lt;branch&gt;  #创建并切换到该分支</div><div class="line">git branch  #查看现有分支</div><div class="line">git branch -d &lt;branch&gt;  #删除指定分支</div><div class="line">git branch --set-upstream &lt;branch_local&gt; &lt;branch_remote&gt;  #指定本地分支与远程分支的链接</div><div class="line">git merge &lt;branch&gt;  #合并指定分支到当前分支</div><div class="line">          --no-ff &lt;branch&gt;  #禁用快速合并</div><div class="line">git merge --no-ff -m &quot;提交说明&quot; &lt;branch&gt;  #普通方式合并，并附提交说明</div><div class="line">git stash  #保存当前工作环境（包括工作区和暂存区）</div><div class="line">git stash list  #查看保存的工作列表</div><div class="line">git stash apply [stash@&#123;X&#125;]  #恢复工作状态，但不删除stash内容</div><div class="line">git stash pop [stash@&#123;X&#125;]  #恢复工作状态，并删除stash内容</div><div class="line">git stash drop [stash@&#123;X&#125;]  #删除stash内容</div><div class="line">git branch -D &lt;branch&gt;  #强制删除分支（常用于未合并的分支）</div></pre></td></tr></table></figure><blockquote><p>HEAD不是直接指向提交点，而是指向分支，分支再指向提交点</p></blockquote><ul><li><h6 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">##error: failed to push some refs to ...</div><div class="line">1. git pull 远程库</div><div class="line">2. 解决冲突（若有），再push</div></pre></td></tr></table></figure><ul><li>分支管理策略图</li></ul><p><a href="https://camo.githubusercontent.com/64ee45ca6222cfce64ec679d18b0c9e6ab0862d0/687474703a2f2f7777772e6c69616f78756566656e672e636f6d2f66696c65732f6174746163686d656e74732f30303133383439303932333933393064333535656230376439643634333035623633323261616634656461633165333030302f30" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/64ee45ca6222cfce64ec679d18b0c9e6ab0862d0/687474703a2f2f7777772e6c69616f78756566656e672e636f6d2f66696c65732f6174746163686d656e74732f30303133383439303932333933393064333535656230376439643634333035623633323261616634656461633165333030302f30" alt="image"></a></p><h5 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git tag  #查看现有标签</div><div class="line">git tag &lt;tag_name&gt;  #给当前所在的commit打标签</div><div class="line">git tag &lt;tag_name&gt; &lt;commit_id&gt;  #给指定commit打标签</div><div class="line">git tag -a &lt;tag_name&gt; -m &quot;标签说明&quot; &lt;commit_id&gt;  #给指定commit打标签，并附说明</div><div class="line">        -s &lt;tag_name&gt; -m &quot;标签说明&quot; &lt;commit_id&gt;  #用gpg私钥签名</div><div class="line">        -d &lt;tag_name&gt;  #删除标签</div><div class="line">git show &lt;tag_name&gt;  #显示标签信息</div><div class="line">git push origin &lt;tag_name&gt;  #推送标签到远程库</div><div class="line">git push origin --tags  #推送所有未推送的标签到远程库</div><div class="line">git push origin :refs/tags/&lt;tag_name&gt;  #删除远程标签（先删除本地，再使用该命令删除）</div></pre></td></tr></table></figure><h5 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;you_name&quot;  #设置全局用户名</div><div class="line">git config --global user.email &quot;email@example.com&quot;  #设置全局邮箱</div><div class="line">git config --global color.ui true  #设置全局颜色显示</div><div class="line">git config --global alias.&lt;alias_name&gt; &lt;&apos;command_name&apos;&gt;  #设置别名</div></pre></td></tr></table></figure><ul><li><p>忽略特殊文件</p><ol><li>工作区创建<code>.gitignore</code>文件</li><li>内容举例，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#Windows:</div><div class="line">Thumbs.db</div><div class="line">ehthumbs.db</div><div class="line">Desktop.ini</div><div class="line"></div><div class="line">#Python:</div><div class="line">*.py[cod]</div><div class="line">*.so</div><div class="line">*.egg</div><div class="line">*.egg-info</div><div class="line">dist</div><div class="line">build</div><div class="line">#My configurations:</div><div class="line">db.ini</div><div class="line">deploy_key_rsa</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git check-ignore -v &lt;file&gt;  #查看忽略该文件的规则</div></pre></td></tr></table></figure><blockquote><p>规则有错时常用上述命令查找定位</p></blockquote><ul><li>配置别名列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">配置别名列表</div><div class="line">git config --global alias.confg &apos;config --global&apos;</div><div class="line">git confg alias.st status</div><div class="line">git confg alias.co checkout</div><div class="line">git confg alias.ci commit</div><div class="line">git confg alias.br branch</div><div class="line">git confg alias.unstage &apos;reset HEAD&apos;</div><div class="line">git confg alias.last &apos;log -1&apos;</div><div class="line">git confg alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;怎样上传代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;第一步：建立git仓库&quot;&gt;&lt;a href=&quot;#第一步：建立git仓库&quot; class=&quot;headerlink&quot; title=&quot;第一步：建立git仓库&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一步：建立git仓库&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;cd到你的本地项目根目录下，执行git命令&lt;/p&gt;
    
    </summary>
    
      <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="http://yoursite.com/2017/10/12/React/"/>
    <id>http://yoursite.com/2017/10/12/React/</id>
    <published>2017-10-12T05:53:57.000Z</published>
    <updated>2017-10-16T03:01:45.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近学了react </p></blockquote><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a><strong>好处</strong></h3><ul><li>自定义标签</li><li>结构清晰</li><li>代码模块化</li><li>更加语义化</li></ul><a id="more"></a><h3 id="不过也有缺点"><a href="#不过也有缺点" class="headerlink" title="不过也有缺点"></a><strong>不过也有缺点</strong></h3><ul><li>浏览器不支持这语法</li><li>必须通过一大堆工具来转换</li></ul><h3 id="一些需要注意的点"><a href="#一些需要注意的点" class="headerlink" title="一些需要注意的点"></a>一些需要注意的点</h3><p><strong>1. react声明组件时，组件名称必须以大写字母开头如</strong>👉：<code>&lt;Todo /&gt;</code><br><strong>2. 每个标签必须闭合,因为采用的 js+xml 写法，如</strong>👉: <code>&lt;input /&gt;</code><br><strong>3. 组件的返回值只能有一个顶层元素，如</strong>👇：</p><p>下面是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">render () &#123;</div><div class="line">  return (</div><div class="line">    &lt;div&gt;1&lt;/div&gt;</div><div class="line">    &lt;div&gt;2&lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>必须这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render () &#123;</div><div class="line">  return (</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;div&gt;1&lt;/div&gt;</div><div class="line">        &lt;div&gt;2&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>4. return后面要加一个括号,目的是防止 JavaScript 代码在解析时自动在换行处添加分号</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> renderSquare(i) &#123;</div><div class="line">        return (</div><div class="line">          &lt;Todo /&gt;</div><div class="line">        );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>5. render()里面不能写 class,for,而是要写成className和htmlFor,因为 class ，for 是 javascript 的关键字，因此不能使用，如</strong>：</p><p>下面是错误的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=“xxx”&gt;</div></pre></td></tr></table></figure><p>而是要写 className：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div className=&quot;xxx&quot;&gt;</div></pre></td></tr></table></figure><p><strong>6. 不要直接更新状态，如</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.state.comment = &apos;Hello&apos;;</div></pre></td></tr></table></figure><p>此代码<strong>不会</strong>重新渲染组件的，之前就这么写，啥反应也没有😂，应该要用<code>setState()</code>:👇</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.setState(&#123;comment: &apos;Hello&apos;&#125;);</div></pre></td></tr></table></figure><p>（<strong>注意！！</strong>：构造函数（constructor）是唯一能够初始化 this.state 的地方。）</p><p><strong>7. 使用style</strong></p><p>我们在 html 可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;background-color:red;&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure><p>但是在 jsx 里面却不能这么写，必须用两个花括号包裹，并且里面不能写<code>-</code>，要用驼峰形式写，如上面的 <code>background-color</code>写成<code>backgroundColor</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;backgroundColor: &apos;red&apos;&#125;&#125;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure><p><strong>8. 关于 setState</strong></p><p>setState方法用于更新当前组件的state状态值，但调用这个方法后，state并不会立即更新，而是在render方法调用后才会更新</p><h3 id="react-特点"><a href="#react-特点" class="headerlink" title="react 特点"></a>react 特点</h3><ol><li><strong>虚拟DOM</strong>: React是以数据驱动的，每次数据变化React都会扫描整个虚拟DOM树，自动计算与上次虚拟DOM的差异变化，然后针对需要变化的部分进行实际的浏览器DOM更新。</li><li><strong>组件化：</strong> React可以从功能角度划分，将UI分解成不同组件，各组件都独立封装，整个UI是由一个个小组件构成的一个大组件，每个组件只关系自身的逻辑，彼此独立（比如你有个按钮，很多页面都有这个按钮，那么就可以把这个按钮封装成该组件）。</li><li><strong>单项数据流</strong>：React只有单向数据流动-从父节点传递到子节点</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学了react &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;好处&quot;&gt;&lt;a href=&quot;#好处&quot; class=&quot;headerlink&quot; title=&quot;好处&quot;&gt;&lt;/a&gt;&lt;strong&gt;好处&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;自定义标签&lt;/li&gt;
&lt;li&gt;结构清晰&lt;/li&gt;
&lt;li&gt;代码模块化&lt;/li&gt;
&lt;li&gt;更加语义化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>first blog</title>
    <link href="http://yoursite.com/2017/10/11/first-blog/"/>
    <id>http://yoursite.com/2017/10/11/first-blog/</id>
    <published>2017-10-11T07:53:57.000Z</published>
    <updated>2017-10-16T03:02:29.246Z</updated>
    
    <content type="html"><![CDATA[<p>這是我第一次寫博客 哈哈哈</p><a id="more"></a><p>我爱你</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是我第一次寫博客 哈哈哈&lt;/p&gt;
    
    </summary>
    
      <category term="傻逼" scheme="http://yoursite.com/categories/%E5%82%BB%E9%80%BC/"/>
    
    
      <category term="隨筆" scheme="http://yoursite.com/tags/%E9%9A%A8%E7%AD%86/"/>
    
  </entry>
  
</feed>
